plugins {
    id 'jvm-component'
    id 'java-lang'
    id 'cpp'
    id 'maven-publish'
    id 'com.bmuschko.vagrant-base' version '2.0'
}

import com.bmuschko.gradle.vagrant.tasks.*
vagrant.installation.validate = false

version = '0.0'
group = 'org.bven'

// Process resources task doesn't get created if there aren't any resources; create a placeholder to ensure that it does.
def placeholder = file('src/main/resources/deleteme')
if (!placeholder.parentFile.exists()) {
    placeholder.parentFile.mkdirs()
}
if (!placeholder.exists()) {
    placeholder.createNewFile()
}

// Looks like this is the only way to add custom header/lib paths from
// outside the project dir.
// https://discuss.gradle.org/t/native-why-does-gradle-ignore-value-set-for-environment-variable-lib-and-libpath/11427
class ExternalLibrary implements NativeDependencySet {

    final FileCollection includeRoots
    final FileCollection linkFiles
    final FileCollection runtimeFiles

    ExternalLibrary(inc, bin, lib) {
        this.includeRoots = inc
        this.runtimeFiles = bin
        this.linkFiles = lib
    }
}

def jni = {
    def javaHome = System.properties.'java.home' + '/..'
    def includes = project.files "${javaHome}/include"
    project.file("${javaHome}/include").eachDir { includes += project.files it }
    new ExternalLibrary(includes, project.files(), project.files())
}()

model {

    platforms {
        ['windows', 'linux', 'osx', 'freebsd-10', 'solaris'].each { os ->
            ['x64', 'arm'].each { arch ->
                "$os-$arch" {
                    architecture arch
                    operatingSystem os
                }
            }
        }
    }

    components {
        archloader(JvmLibrarySpec)
        main(JvmLibrarySpec) {
            dependencies { 
                library 'archloader'
            }
        }
        hello(NativeLibrarySpec) { library ->
            $.platforms.all {
                library.targetPlatform it.name
            }

            binaries.all {
                lib jni
            }
        }
    }

    tasks {
        javah(Exec) {
            ['hello'].each{ name ->

                def nativeIncludes = "src/${name}/headers"
                def mainClassName = "${project.group}.${name}.Native"
                def classes = $.tasks.compileMainJarMainJava
                def classpath = "${classes.destinationDir}"

                commandLine "javah", "-d", nativeIncludes, "-classpath", classpath, mainClassName

                inputs.dir classpath
                outputs.dir nativeIncludes

                dependsOn classes
            }
        }

        copyLibs(Copy) {
            into 'src/main/resources/lib'

            ($.binaries.withType(SharedLibraryBinary)).each {
                lib ->

                if (lib.buildable) {
                    from lib.sharedLibraryFile, {
                        into "${lib.targetPlatform.name}"
                    }
                    dependsOn lib.tasks
                }
            }
        }

        processMainJarMainResources {
            placeholder.delete() // Placeholder has served its purpose
            it.dependsOn "copyLibs"
        }

        withType(CppCompile) {
            it.dependsOn "javah"
        }

        run(JavaExec) {
            def compile = $.tasks.compileMainJarMainJava;
            def jar = $.tasks.createMainJar;
            dependsOn $.tasks.mainJar
            classpath compile.classpath
            classpath jar.outputs
            main = 'org.bven.hello.Native'
        }

        allUp(VagrantUp)

        allHalt(VagrantHalt) {
            mustRunAfter "allUp"
        }

        ['linux', 'windows', 'freebsd'].each { os ->
            "${os}Up"(VagrantUp) {
                commands.add os
            }

            "${os}Build"(Vagrant) {
                dependsOn "${os}Up"
                commands = ['ssh', os, '-c', "/vagrant/gradlew -p /vagrant -PbuildDir='${os}Build' --project-cache-dir /tmp mainJar"]
            }

            "${os}Run"(Vagrant) {
                dependsOn "${os}Up"
                commands = ['ssh', os, '-c', "/vagrant/gradlew -p /vagrant -PbuildDir='${os}Build' --project-cache-dir /tmp run"]
            }

            "${os}Halt"(VagrantHalt) {
                mustRunAfter "${os}Run"
                commands.add os
            }

            build.dependsOn "${os}Build"
            build.dependsOn "${os}Halt"
            allHalt.dependsOn "${os}Halt"
        }

        wrapper {
            gradleVersion = '2.10'
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication)
        }
    }
}

