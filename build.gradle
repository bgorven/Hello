plugins {
    id 'jvm-component'
    id 'java-lang'
    id 'cpp'
    id 'maven-publish'
}

version = '0.0'
group = 'org.bven'

// Process resources task doesn't get created if there aren't any resources; create a placeholder to ensure that it does.
def placeholder = file('src/main/resources/deleteme')
if (!placeholder.exists()) {
    placeholder.createNewFile()
}

// Looks like this is the only way to add custom header/lib paths from
// outside the project dir.
// https://discuss.gradle.org/t/native-why-does-gradle-ignore-value-set-for-environment-variable-lib-and-libpath/11427
class ExternalLibrary implements NativeDependencySet {

    final FileCollection includeRoots
    final FileCollection linkFiles
    final FileCollection runtimeFiles

    ExternalLibrary(inc, bin, lib) {
        this.includeRoots = inc
        this.runtimeFiles = bin
        this.linkFiles = lib
    }
}

def jni = {
    def javaHome = System.env.'JAVA_HOME'
    try {
        javaHome = "cygpath -w '$javaHome'".execute().text.trim()
    } catch (IOException e) { 
        // Not in cygwin; if you're running this from msys{,2} you're out of luck, maybe?
    }
    def includes = project.files "${javaHome}/include"
    project.file("${javaHome}/include").eachDir { includes += project.files it }
    new ExternalLibrary(includes, project.files(), project.files())
}()

model {

    platforms {
        ['windows', 'linux', 'osx', 'freebsd', 'solaris'].each { os ->
            ['x86', 'x64', 'arm'].each { arch ->
                "$os-$arch" {
                    architecture arch
                    operatingSystem os
                }
            }
        }
    }

    components {
        main(JvmLibrarySpec)
        cpp(NativeLibrarySpec) { library ->
            $.platforms.all {
                library.targetPlatform it.name
            }

            binaries.all {
                lib jni
            }
        }
    }

    tasks {
        javah(Exec) {

            def nativeIncludes = "src/cpp/headers"
            def mainClassName = "${project.group}.${project.name}.Native"
            def classes = $.tasks.compileMainJarMainJava
            def classpath = "${classes.destinationDir}"

            commandLine "javah", "-d", nativeIncludes, "-classpath", classpath, mainClassName

            inputs.dir classpath
            outputs.dir nativeIncludes

            it.dependsOn classes
        }

        copyDlls(Copy) {
            def libs = $.binaries.withType(SharedLibraryBinary)
            libs.each { lib ->
                if (lib.buildable) {
                    into 'src/main/resources'
                    from lib.sharedLibraryFile, {
                        into "${lib.targetPlatform.name}"
                    }
                    it.dependsOn lib.tasks
                }
            }
        }

        processMainJarMainResources {
            placeholder.delete() // Placeholder has served its purpose
            it.dependsOn $.tasks.copyDlls
        }

        withType(CppCompile) {
            it.dependsOn $.tasks.javah
        }

        wrapper {
            gradleVersion = '2.10'
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication)
        }
    }
}

