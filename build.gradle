plugins {
    id 'jvm-component'
    id 'java-lang'
    id 'cpp'
    id 'maven-publish'
}

version = '0.0'
group = 'org.bven'

// Process resources task doesn't get created if there aren't any resources; create a placeholder to ensure that it does.
def placeholder = file('src/main/resources/deleteme')
if (!placeholder.parentFile.exists()) {
    placeholder.parentFile.mkdirs()
}
if (!placeholder.exists()) {
    placeholder.createNewFile()
}

// Looks like this is the only way to add custom header/lib paths from
// outside the project dir.
// https://discuss.gradle.org/t/native-why-does-gradle-ignore-value-set-for-environment-variable-lib-and-libpath/11427
class ExternalLibrary implements NativeDependencySet {

    final FileCollection includeRoots
    final FileCollection linkFiles
    final FileCollection runtimeFiles

    ExternalLibrary(inc, bin, lib) {
        this.includeRoots = inc
        this.runtimeFiles = bin
        this.linkFiles = lib
    }
}

def jni = {
    def javaHome = System.env.'JAVA_HOME'
    try {
        javaHome = "cygpath -w '$javaHome'".execute().text.trim()
    } catch (IOException e) { 
        // Not in cygwin; if you're running this from msys{,2} you're out of luck, maybe?
    }
    def includes = project.files "${javaHome}/include"
    project.file("${javaHome}/include").eachDir { includes += project.files it }
    new ExternalLibrary(includes, project.files(), project.files())
}()

model {

    platforms {
        ['windows', 'linux', 'osx', 'freebsd', 'solaris'].each { os ->
            ['x86', 'x64', 'arm'].each { arch ->
                "$os-$arch" {
                    architecture arch
                    operatingSystem os
                }
            }
        }
    }

    components {
        archloader(JvmLibrarySpec)
        main(JvmLibrarySpec) {
            dependencies { 
                library 'archloader'
            }
        }
        hello(NativeLibrarySpec) { library ->
            $.platforms.all {
                library.targetPlatform it.name
            }

            binaries.all {
                lib jni
            }
        }
    }

    tasks {
        javah(Exec) {
            ['hello'].each{ name ->

                def nativeIncludes = "src/${name}/headers"
                def mainClassName = "${project.group}.${name}.Native"
                def classes = $.tasks.compileMainJarMainJava
                def classpath = "${classes.destinationDir}"

                commandLine "javah", "-d", nativeIncludes, "-classpath", classpath, mainClassName

                inputs.dir classpath
                outputs.dir nativeIncludes

                dependsOn classes
            }
        }

        copyDlls(Copy) {
            into 'src/main/resources/lib'
            
            ($.binaries.withType(SharedLibraryBinary)).each {
                lib ->
                
                if (lib.buildable) {
                    from lib.sharedLibraryFile, {
                        into "${lib.targetPlatform.name}"
                    }
                    dependsOn lib.tasks
                }
            }
        }

        processMainJarMainResources {
            placeholder.delete() // Placeholder has served its purpose
            it.dependsOn $.tasks.copyDlls
        }

        withType(CppCompile) {
            it.dependsOn $.tasks.javah
        }
        
        run(JavaExec) {
            def compile = $.tasks.compileMainJarMainJava;
            def jar = $.tasks.createMainJar;
            dependsOn $.tasks.mainJar
            classpath compile.classpath
            classpath jar.outputs
            main = 'org.bven.hello.Native'
        }

        wrapper {
            gradleVersion = '2.10'
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication)
        }
    }
}

