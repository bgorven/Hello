plugins {
    id 'jvm-component'
    id 'java-lang'
    id 'cpp'
    id 'maven-publish'
}

version = '0.0'
group = 'org.bven'

// Process resources task doesn't get created if there aren't any resources; create a placeholder to ensure that it does.
def placeholder = file('src/main/resources/deleteme')
if (!placeholder.parentFile.exists()) {
    placeholder.parentFile.mkdirs()
}
if (!placeholder.exists()) {
    placeholder.createNewFile()
}
placeholder.deleteOnExit()

// Looks like this is the only way to add custom header/lib paths from
// outside the project dir.
// https://discuss.gradle.org/t/native-why-does-gradle-ignore-value-set-for-environment-variable-lib-and-libpath/11427
class JNIDependency implements NativeDependencySet {
    final FileCollection includeRoots
    final FileCollection linkFiles
    final FileCollection runtimeFiles

    JNIDependency(Project project) {
        def javaHome = System.properties.'java.home' + '/..'
        def includes = project.files "${javaHome}/include"
        project.file("${javaHome}/include").eachDir { includes += project.files it }
        this.includeRoots = includes
        this.runtimeFiles = project.files()
        this.linkFiles = project.files()
    }
}

@Managed interface JNILibrarySpec extends NativeLibrarySpec {
    void setClasses(List<String> classes);
    List<String> getClasses();
    void setPkg(String dir);
    String getPkg();
    void setLibrary(String library);
    String getLibrary();
}

class JavahCompile extends Exec {}

class JNIRules extends RuleSource {
    @Mutate void createJavahTask(ModelMap<Task> tasks, ModelMap<JNILibrarySpec> libs, @Path("binaries") ModelMap<JvmBinarySpec> binaries) {
        libs.each { lib ->
            def headerDir = "src/${lib.baseName}/headers"
            def targets = binaries.findAll{ it.library.name == lib.library }
            def classpath = targets.collect{ it.classesDir }.join(File.pathSeparator)

            tasks.create("${lib.baseName}Javah", JavahCompile) { task ->
                commandLine(["javah", "-d", headerDir, "-classpath", classpath] + lib.classes.collect{ "${lib.pkg}.${it}" })

                inputs.dir targets.collect{ it.classesDir }
                outputs.dir headerDir
                targets.each{ 
                    it.tasks.withType(PlatformJavaCompile) { 
                        task.dependsOn it
                    }
                }
            }
        }
    }
    
    @Mutate void createCopyLibsTask(ModelMap<Task> tasks, @Path("binaries") ModelMap<JvmBinarySpec> binaries, @Path("binaries") ModelMap<SharedLibraryBinarySpec> libs) {
        libs.findAll{ it.buildable && (it.library instanceof JNILibrarySpec) }.each{ lib ->
            binaries.findAll{ it.library.name == lib.library.library }.each{ bin ->
                String task = "copy${lib.name.capitalize()}LibsTo${bin.library.name.capitalize()}"
                tasks.create(task, Copy) {
                    into "src/main/resources/lib/${lib.library.pkg}"
                    from lib.sharedLibraryFile, {
                        into "${lib.targetPlatform.name}"
                    }
                    dependsOn lib.tasks
                }
                bin.tasks.withType(ProcessResources) {
                    //Dodgy doing this here; don't think we should be mutating any parameters except the first one.
                    it.dependsOn task
                }
            }
        }
    }
}

apply plugin: JNIRules

repositories {
    maven { url "https://jitpack.io" }
}

model {
    toolChains {
        clang(Clang)
    }

    platforms {
        ['windows', 'linux', 'osx', 'freebsd-10', 'solaris'].each { os ->
            ['x86', 'x64', 'arm'].each { arch ->
                "$os-$arch" {
                    architecture arch
                    operatingSystem os
                }
            }
        }
    }

    components {
        main(JvmLibrarySpec) {
            dependencies { 
                module 'com.github.bgorven:Loader:1.0.0'
            }
        }
        Native(JNILibrarySpec) { jniLibSpec ->
            library "main"
            pkg "org.bven.hello"
            classes ["Native"]

            $.platforms.all {
                jniLibSpec.targetPlatform it.name
            }

            binaries.all {
                lib new JNIDependency(project)
            }
        }
    }

    tasks {
        run(JavaExec) {
            def compile = $.tasks.compileMainJarMainJava;
            def jar = $.tasks.createMainJar;
            dependsOn $.tasks.mainJar
            classpath compile.classpath
            classpath jar.outputs
            main = 'org.bven.hello.Native'
        }

        wrapper {
            gradleVersion = '3.0-rc-1'
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication)
        }
    }
}

