plugins {
    id 'jvm-component'
    id 'java-lang'
    id 'cpp'
    id 'maven-publish'
    id 'com.bmuschko.vagrant-base' version '2.0'
}

import com.bmuschko.gradle.vagrant.tasks.*
vagrant.installation.validate = false

version = '0.0'
group = 'org.bven'
ext.nativePackage = 'org.bven.hello'

// Process resources task doesn't get created if there aren't any resources; create a placeholder to ensure that it does.
def placeholder = file('src/main/resources/deleteme')
if (!placeholder.parentFile.exists()) {
    placeholder.parentFile.mkdirs()
}
if (!placeholder.exists()) {
    placeholder.createNewFile()
}

// Looks like this is the only way to add custom header/lib paths from
// outside the project dir.
// https://discuss.gradle.org/t/native-why-does-gradle-ignore-value-set-for-environment-variable-lib-and-libpath/11427
class ExternalLibrary implements NativeDependencySet {

    final FileCollection includeRoots
    final FileCollection linkFiles
    final FileCollection runtimeFiles

    ExternalLibrary(inc, bin, lib) {
        this.includeRoots = inc
        this.runtimeFiles = bin
        this.linkFiles = lib
    }
}

def jni = {
    def javaHome = System.properties.'java.home' + '/..'
    def includes = project.files "${javaHome}/include"
    project.file("${javaHome}/include").eachDir { includes += project.files it }
    new ExternalLibrary(includes, project.files(), project.files())
}()

@Managed interface JNILibrarySpec extends NativeLibrarySpec {
    void setNativeClass(String nativeClass);
    String getNativeClass();
}

repositories {
    maven { url "https://jitpack.io" }
}

model {

    platforms {
        ['windows', 'linux', 'osx', 'freebsd-10', 'solaris'].each { os ->
            ['x86', 'x64', 'arm'].each { arch ->
                "$os-$arch" {
                    architecture arch
                    operatingSystem os
                }
            }
        }
    }

    components {
        main(JvmLibrarySpec) {
            dependencies { 
                module 'com.github.bgorven:Loader:1.0.0'
            }
        }
        Native(JNILibrarySpec) { library ->
            nativeClass "org.bven.hello.Native"

            $.platforms.all {
                library.targetPlatform it.name
            }

            binaries.all {
                lib jni
            }
        }
    }

    tasks {
        javah(Exec) {
            $.components.withType(JNILibrarySpec).each{ lib ->

                def name = lib.baseName
                def nativeIncludes = "src/${name}/headers"
                def mainClassName = "${lib.nativeClass}"
                def classes = $.tasks.compileMainJarMainJava
                def classpath = "${classes.destinationDir}"

                commandLine "javah", "-d", nativeIncludes, "-classpath", classpath, mainClassName

                inputs.dir classpath
                outputs.dir nativeIncludes

                dependsOn classes
            }
        }

        copyLibs(Copy) {
            into "src/main/resources/lib/${nativePackage}"

            $.binaries.withType(SharedLibraryBinarySpec).each {
                lib ->

                if (lib.buildable) {
                    from lib.sharedLibraryFile, {
                        into "${lib.targetPlatform.name}"
                    }
                    dependsOn lib.tasks
                    println "${lib} buildable"
                } else {
                    println "${lib} not buildable"
                }
            }
        }

        processMainJarMainResources {
            placeholder.delete() // Placeholder has served its purpose
            it.dependsOn "copyLibs"
        }

        withType(CppCompile) {
            it.dependsOn "javah"
        }

        run(JavaExec) {
            def compile = $.tasks.compileMainJarMainJava;
            def jar = $.tasks.createMainJar;
            dependsOn $.tasks.mainJar
            classpath compile.classpath
            classpath jar.outputs
            main = 'org.bven.hello.Native'
        }

        allUp(VagrantUp)

        allHalt(VagrantHalt) {
            mustRunAfter "allUp"
        }

        //I don't know how to get the list of boxes from the Vagrantfile :(
        ['linux', 'windows', 'freebsd'].each { os ->
            "${os}Up"(VagrantUp) {
                commands.add os
            }
            
            def gradleTask = { task ->
                if (os == 'windows') {
                    return ['ssh', os, '-c', "/vagrant/gradlew.bat -p 'c:\\vagrant' -PbuildDir='${os}Build' --project-cache-dir /tmp ${task}"]
                } else {
                    return ['ssh', os, '-c', "/vagrant/gradlew -p /vagrant -PbuildDir='${os}Build' --project-cache-dir /tmp ${task}"]
                }
            }

            "${os}Build"(Vagrant) {
                dependsOn "${os}Up"
                commands = gradleTask('mainJar')
            }

            "${os}Run"(Vagrant) {
                dependsOn "${os}Up"
                commands = gradleTask('run')
            }

            "${os}Halt"(VagrantHalt) {
                mustRunAfter "${os}Run"
                commands.add os
            }

            build.dependsOn "${os}Build"
            build.dependsOn "${os}Halt"
            allHalt.dependsOn "${os}Halt"
        }

        wrapper {
            gradleVersion = '3.0-rc-1'
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication)
        }
    }
}

